// *************************************************************************************************************
// *   v1190a 
// *   Alexis Fagot
// *   20/01/2015
// *   Based on v1290a file from :
// *   Avia Raviv & Y. Benhammou
// *   14/03/2012
// *************************************************************************************************************

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <ostream>
#include <sstream>
#include <cmath>
#include <vector>
#include <string>
#include <iomanip>
#include <map>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/io.h>
#include <sys/timeb.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include "CAENVMElib.h"
#include "CAENVMEoslib.h"
#include "CAENVMEtypes.h"

#include "v1190a.h"
#include "v1190aDecoder.h"
#include "v1718.h"
   
using namespace std;
  
v1190a::v1190a(long handle, Data32 address)
{
   Address=address;              //See page 35
   DataWidth=cvD16;              //See in CAENVMEtypes.h CVDataWidth enum
   AddressModifier=cvA24_U_DATA; //See in CAENVMEtypes.h CVAddressModifier enum
   Handle=handle;
}

// *************************************************************************************************************
 
v1190a::~v1190a()
{

}

// *************************************************************************************************************

Data16 v1190a::read_op_reg(Data32 Address)
{
   //Checks the Read OK bit
   int time = 0;
   Data16 ro_bit;

   do
   {
       CAENVME_ReadCycle(Handle,Address+ADD_MICRO_HND_V1190A,&ro_bit,AddressModifier,DataWidth);
       time++;
   } while(ro_bit != READ_OK && time < 100000);

   if(time == 100000)
   {
       printf("Reads - timeout error\n");
       exit(0);
    }
   else
   {
       sleep(1);      /*** delay 12ms, internal delay ***/
       //Reads opcode
       CAENVME_ReadCycle(Handle,Address+ADD_MICRO_V1190A,&ro_bit,AddressModifier,DataWidth );
       return ro_bit;
   }
}

// *************************************************************************************************************

Data16 v1190a::write_op_reg(Data32 Address, int code)
{
   //Checks the Write OK bit
   int time = 0;
   Data16 wo_bit;
   do
   {
      CAENVME_ReadCycle(Handle,Address+ADD_MICRO_HND_V1190A,&wo_bit,AddressModifier,DataWidth );
      time++;
   } while(wo_bit != WRITE_OK && time < 100000);

   if(time == 100000)
   {
      printf("Write opcode - timeout error\n");
      exit(0);
   }
   else
   {
      sleep(1);      /*** delay 12 msec, internal delay ***/
      //Writes opcode = code
      CAENVME_WriteCycle(Handle,Address+ADD_MICRO_V1190A,&code,AddressModifier,DataWidth);
      return 0;
    }
}

// *************************************************************************************************************

void v1190a::Reset(){ //Reset the TDC (Software clear) and wait 2 s
    cout << "Reset the TDC...\n\n";
    int reset=0x0;
    CAENVME_WriteCycle(Handle,Address+ADD_SW_CLEAR_V1190A,&reset,AddressModifier,DataWidth);
    sleep(2);
}

// *************************************************************************************************************

void v1190a::TestWR(Data16 value){ //Test : try to write/read 16 bit word
    Data16 test=value;
    CAENVME_WriteCycle(Handle,Address+ADD_DUMMY16_V1190A,&test,AddressModifier,DataWidth);

    test=0;
    CAENVME_ReadCycle(Handle,Address+ADD_DUMMY16_V1190A,&test,AddressModifier,DataWidth);

    printf("The result of W/R test is : %d (%d tested)\n\n",test,value);
}

// *************************************************************************************************************

void v1190a::CheckStatus(){ //Status of the TDC (Status register)
    cout << "Status of the TDC...\n\n";
    Data16 status;
    CAENVME_ReadCycle(Handle,Address+ADD_STATUS_V1190A,&status,AddressModifier,DataWidth);
    printf("TDC STATUS is : %X\n\n",status);
}

// *************************************************************************************************************

void v1190a::CheckCommunication(){//Check the communication with the micro controller
    cout << "Control of the communication with the uController...\n";
    write_op_reg(Address,OPCODE_READ_SPARE_V1190A);
    printf("...gives : 0x%4X  (0x5555 : OK)\n\n", read_op_reg(Address));
}

// *************************************************************************************************************

void v1190a::SetTDCTestMode(SetMode mode){//Enable/Disable TDC test mode
    if(mode == 1)
        write_op_reg(Address, OPCODE_EN_TEST_MODE_V1190A);
    else if(mode == 0)
        write_op_reg(Address, OPCODE_DIS_TEST_MODE_V1190A);
}

// *************************************************************************************************************

void v1190a::SetTrigMatching(){//Set trigger matching mode
    write_op_reg(Address, OPCODE_TRG_MATCH_V1190A);
}

// *************************************************************************************************************

void v1190a::SetTrigTimeSubstraction(SetMode mode){//Enable/Disable substraction of trigger time
    if(mode == 1)
        write_op_reg(Address, OPCODE_EN_SUB_TRG_V1190A);
    else if(mode == 0)
        write_op_reg(Address, OPCODE_DIS_SUB_TRG_V1190A);
}

// *************************************************************************************************************

void v1190a::SetTrigWindowWidth(){
    // Time unit = 25ns
    double timewindowus = (double)TRIG_WIN_WIDTH_V1990A * 25e-3;
    printf("Window width is set to 0x%2X (%fus)\n",TRIG_WIN_WIDTH_V1990A,timewindowus);
    write_op_reg(Address, OPCODE_SET_WIN_WIDTH_V1190A);
    write_op_reg(Address, TRIG_WIN_WIDTH_V1990A);
}

// *************************************************************************************************************

void v1190a::SetTrigWindowOffset(){
    // Time unit = 25ns
    double timewindowus = (double)TRIG_WIN_OFFSET_V1190A * 25e-3;
    printf("Window Offset is set to 0x%2X (%fus)\n",TRIG_WIN_OFFSET_V1190A,timewindowus);
    write_op_reg(Address, OPCODE_SET_WIN_OFFSET_V1190A);
    write_op_reg(Address, TRIG_WIN_OFFSET_V1190A);
}

// *************************************************************************************************************

void v1190a::SetTrigSearchMargin(){
    // Time unit = 25ns
    int timewindowns = (int)TRIG_SRCH_MARGIN_V1190A * 25;
    printf("Extra search margin is set to 0x%2X (%dns)\n",TRIG_SRCH_MARGIN_V1190A,timewindowns);
    write_op_reg(Address, OPCODE_SET_SW_MARGIN_V1190A);
    write_op_reg(Address, TRIG_SRCH_MARGIN_V1190A);
}

// *************************************************************************************************************

void v1190a::SetTrigRejectionMargin(){
    // Time unit = 25ns
    int timewindowns = (int)TRIG_REJ_MARGIN_V1190A * 25;
    printf("Rejection margin is set to 0x%2X (%dns)\n",TRIG_REJ_MARGIN_V1190A,timewindowns);
    write_op_reg(Address, OPCODE_SET_REJ_MARGIN_V1190A);
    write_op_reg(Address, TRIG_REJ_MARGIN_V1190A);
}

// *************************************************************************************************************

void v1190a::GetTrigConfiguration(){ //Read and print trigger configuration
    write_op_reg(Address, OPCODE_READ_TRG_CONF_V1190A);

    Data16 MatchWindowWidth,WindowOffset,ExtraSearchWindowWidth,RejectMargin,TriggerTimeSubtraction;
    MatchWindowWidth        =read_op_reg(Address);
    WindowOffset            =read_op_reg(Address);
    ExtraSearchWindowWidth  =read_op_reg(Address);
    RejectMargin            =read_op_reg(Address);
    TriggerTimeSubtraction  =read_op_reg(Address);

    printf("Match Window Width :                 0x%04X\n"  ,MatchWindowWidth);
    printf("Window Offset :                      0x%04X\n"  ,WindowOffset);
    printf("Extra Search Window Width :          0x%04X\n"  ,ExtraSearchWindowWidth);
    printf("Reject Margin :                      0x%04X\n"  ,RejectMargin);
    printf("Trigger Time Subtraction :           %d\n\n"    ,TriggerTimeSubtraction);
}

// *************************************************************************************************************

void v1190a::SetTrigConfiguration(){ //Set and print trigger configuration
    // Each parameter is defined taking into account that the time unit is 25ns
    this->SetTrigWindowWidth();
    this->SetTrigWindowOffset();
    this->SetTrigSearchMargin();
    this->SetTrigRejectionMargin();

    this->GetTrigConfiguration();
}

// *************************************************************************************************************

void v1190a::SetTDCDetectionMode(EdgeMode mode){
    cout << "Edge detection set to trailing and leading (0b11)\n";
    write_op_reg(Address,OPCODE_SET_DETECTION_V1190A);              //Edge detection selection
    write_op_reg(Address,mode);
    write_op_reg(Address,OPCODE_READ_DETECTION_V1190A);             //Edge detection readout
    printf("Edge readout :                       %X\n",(read_op_reg(Address) & 0b11));
}

// *************************************************************************************************************

void v1190a::GetTDCResolution(){ //Resolution readout
    write_op_reg(Address,OPCODE_READ_RES_V1190A);
    printf("Resoltion :                          %X\n\n",(read_op_reg(Address) & 0b11));
}

// *************************************************************************************************************

void v1190a::SetTDCDeadTime(DeadTime time){
    cout << "Channel dead time between hits set to 5ns (00)\n";
    write_op_reg(Address,OPCODE_SET_DEAD_TIME_V1190A);              //Set channel dead time
    write_op_reg(Address,time);
    write_op_reg(Address,OPCODE_READ_DEAD_TIME_V1190A);             //Channel dead time readout
    printf("Channel dead time :                  %X\n\n",(read_op_reg(Address) & 0b11));
}

// *************************************************************************************************************

void v1190a::SetTDCHeadTrailer(SetMode mode){ //Enable/Disable TDC header and trailer
    if(mode == 1)
        write_op_reg(Address,OPCODE_EN_HEAD_TRAILER_V1190A);
    else if(mode == 0)
        write_op_reg(Address,OPCODE_DIS_HEAD_TRAILER_V1190A);

    write_op_reg(Address,OPCODE_READ_HEAD_TRAILER_V1190A);
    printf("TDC header/trailer status (on/off) : %X\n", (read_op_reg(Address) & 0b1));
}

// *************************************************************************************************************

void v1190a::SetTDCEventSize(HitMax size){ //Maximum number of hits per event readout
    write_op_reg(Address,OPCODE_SET_EVENT_SIZE_V1190A);
    write_op_reg(Address,size);
    write_op_reg(Address,OPCODE_READ_EVENT_SIZE_V1190A);
    printf("Maximum number of hit/event :        %X\n\n",(read_op_reg(Address) & 0b1111));
}

// *************************************************************************************************************

void v1190a::SwitchChannels(SetMode mode){ //Enable all channels
    if(mode == 1){
        write_op_reg(Address,OPCODE_EN_ALL_CH_V1190A);

        write_op_reg(Address,OPCODE_READ_EN_PATTERN_V1190A);
        for(int i = 0; i<8; i++){
            int first = i*16;
            int last = (i+1)*16-1;
            printf("Channels enabled (%3d-%3d):           %X\n", first, last, (read_op_reg(Address) & 0xFFFF));
        }
    } else if (mode == 0)
        write_op_reg(Address,OPCODE_DIS_ALL_CH_V1190A);
}

// *************************************************************************************************************

void v1190a::Set()
{
    cout << "*************   START TO SET THE TDC   *************\n\n";

    Reset();
    TestWR(TEST_WR);
    CheckStatus();
    CheckCommunication();
    SetTDCTestMode(DISABLE);
	
    cout << "************   Trigger configuration   *************\n\n";

    SetTrigMatching();
    SetTrigTimeSubstraction(ENABLE);
    SetTrigConfiguration();

    cout << "********   TDC edge detection/resolution   *********\n\n";

    SetTDCDetectionMode(EdgeMode_Both);
    GetTDCResolution();
    SetTDCDeadTime(DT_5ns);

    cout << "*****************   TDC readout   ******************\n\n";

    SetTDCHeadTrailer(ENABLE);
    SetTDCEventSize(HITS_UNLIMITED);

    cout << "************   Enabling the channels   *************\n\n";

    SwitchChannels(ENABLE);
}

// *************************************************************************************************************

bool v1190a::IsEventFIFOReady(v1718 * vme){
    Data16 Data;
    Data = vme->ReadShort( Address + ADD_EVENT_FIFO_STATUS_V1190A );
    if( vme->GetStatus() != cvSuccess )
        cerr << "\n[ERR:ModuleV1190A]: Cannot event FIFO register.\n" << vme->GetError() << endl;

    printf("Event FIFO Status:                    %X\n", Data);
    return ( Data & EVENT_FIFO_DREADY_V1190A ) != 0;
}

// *************************************************************************************************************

Data32 v1190a::ReadEventFIFO(v1718 * vme){
    Data32 Data = 0;
    if( IsEventFIFOReady(vme)) {
        Data = vme->ReadLong( Address + ADD_EVENT_FIFO_V1190A );
        if( vme->GetStatus() != cvSuccess )
            cerr << "\n[ERR:ModuleV1190A]: Cannot read event FIFO.\n" << vme->GetError() << endl;
    }
    return Data;
}

// *************************************************************************************************************

Data16 v1190a::FIFOWordCount( Data32 fifocounts ){
    return ( fifocounts & FIFO_WORDCOUNT_MASK_V1190A) >> FIFO_WORDCOUNT_RSHIFT_V1190A;
}

// *************************************************************************************************************

bool v1190a::IsGlobalTrailer( Data32 data ){
    return ( ( data & TYPE_MASK_V1190A ) == GLOBAL_TRAILER_V1190A );
}

// *************************************************************************************************************

bool v1190a::IsFiller( Data32 data ){
    return ( ( data & TYPE_MASK_V1190A ) == FILLER_LONG_V1190A );
}

// *************************************************************************************************************

Data32 v1190a::ReadPacket(void* buffer,Data32 nMax,v1718 * vme){
    Data32* packet = (Data32*) buffer;
    Data32 nRead   = 0;

    // Loop over the read until we get a data word that has
    // either the TDC_TRAILER or FILLER_LONG type mask value.
    // Note that if we run out of user buffer we just stop incrementing
    // the counter/pointer.
    bool done(false);

    while(!done) {
        Data32 datum = vme->ReadLong(Address + ADD_OUT_BUFFER_V1190A);
        *packet = datum;
        if(IsGlobalTrailer( datum ) || IsFiller( datum ))
            done = true;        // Last read.
        if( nRead < nMax ) {    // overwrite last word if output full.
            packet++;
            nRead++;
        }
    }
    return nRead;
}

// *************************************************************************************************************

Data32 v1190a::ReadValid( void* buffer, Data32 nMax, v1718 * vme ){
    Data32* pLongs = (Data32*)buffer;
    Data32 nRead  = 0;

    bool done(false);

    while(!done) {
        Data32 datum = vme->ReadLong(Address + ADD_OUT_BUFFER_V1190A);
        *pLongs++ = datum;
        nRead++;
        if(IsGlobalTrailer(datum) || IsFiller(datum) || (nRead == nMax))
            done = true;
    }
    return nRead;
}

// *************************************************************************************************************

bool v1190a::IsSetStatusReg(Data32 aBit,v1718 * vme){
    Data16 Data;
    Data = vme->ReadShort(Address + ADD_STATUS_V1190A);
    if(vme->GetStatus() != cvSuccess )
        cerr << "\n[ERR:ModuleV1190A]: Cannot read status register.\n"<< vme->GetError() << endl;

    return ( Data & ( 1 << aBit ) ) != 0;
}

// *************************************************************************************************************

Data32 v1190a::ReadData(void* buffer, Data32 nMax,v1718 * vme){
    if ( IsSetStatusReg(0b11,vme) )
        return ReadPacket( buffer, nMax , vme );
    else
        return ReadValid( buffer, nMax , vme) ;
}

// *************************************************************************************************************

bool v1190a::Read(v1718 * vme){

    printf("Status register :     %X\n",IsSetStatusReg(0b11,vme));

    Data32 data;
    Data16 EventStored;
    CAENVME_ReadCycle(Handle, Address+ADD_EVENT_STORED_V1190A, &EventStored, cvA32_U_DATA, cvD16 );
    printf("N Event stored :      %d\n", EventStored);

    while(EventStored !=0)
    {
      CAENVME_ReadCycle(Handle,Address+0x0000,&data,cvA32_U_DATA,cvD32);
  //	cout << "raw data : "<< data <<endl;
      switch(data & STATUS_TDC_V1190A)
          {
              case(GLOBAL_HEADER_V1190A):
                          cout << "GLOBAL HEADER " ;
                          cout << " Event Count : " << ((data>>5) & 0x3FFFFF)<<endl;
                          break;
              case(GLOBAL_TRAILER_V1190A):
                          cout <<"GLOBAL TRAILER ";
                          cout <<"Word Count " << (data & 0xFFF)<<endl;
                          break;
              case(TDC_HEADER_V1190A):
                          cout <<"TDC HEADER ";
                          cout <<"Event id : " << ( (data>>12) & 0x00FFF) << endl;
                          break;
              case(TDC_DATA_V1190A):
                          cout <<"Data ";
                          cout << " Rise/Fall : "<< ((data>>26) & 0x01) ;
                          cout << " Channel : "<<((data>>19) & 0x07F ) ;
                          cout << " Value : "<< ( data & 0x007FFFF)<<endl ;
                          break;

          }
    }

/*
    const unsigned TDC_WAITLOOP = 5000000;
    Data32 TDCData[ 32768 ];

    //Is called to readout data on module
    timespec rt1, at1;
    rt1.tv_sec = 0;
    rt1.tv_nsec = 5; // timeout in nsec

    Data32 count = 0;

     while( !IsSetStatusReg(0b11,vme) && ( count < TDC_WAITLOOP ) ){
        if ( nanosleep( &rt1, &at1 ) != 0 ) cout << "Nanosleep failed\n";
        count += rt1.tv_nsec;
    }

    cout << "Cycles " << count << endl;

    if( IsSetStatusReg(0b11,vme) ) {
        Data32 FIFO = ReadEventFIFO(vme);

        Data16 nWords = FIFOWordCount(FIFO);

        Data32 nRead = ReadData(TDCData,nWords,vme);

        Data16 tdc = 0;
        long channel = -1;
        Data32 data = 0;

        //TODO: Do unpacking here..
        //unsigned channelOffset = this->_nChannels / this->_nChipCount;

        std::vector< std::pair<double,double> > Hits;
        Hits.clear();

        double eventTime=0;

        for( Data32 i = 0; i < nRead; ++i ){

            v1190aDecoder decoder( TDCData[ i ] );
            decoder.Decode();
            if(decoder.IsTdcHeader()){
                tdc = decoder.GetTdc();
            } else if(decoder.IsMeasurement()){
                unsigned RAWchannel = decoder.GetChannel();

                /*if( this->_boardModel == 1190 )
                    channel = channelOffset * tdc + RAWchannel;
                else
                    channel = RAWchannel;//

                data = decoder.GetMeasurement();
                cout    //<< "Board Type = "          << this->_boardModel
                        << "\tTDC = "               << tdc
                        //<< "\tchannel Offset = "    << channelOffset
                        << "\tch = "                << RAWchannel
                        << "\tChannel = "           << channel
                        << "\tdata = "              << data
                        << endl;

                if(RAWchannel==16)
                    eventTime=data;
                else
                    Hits.push_back(std::make_pair(RAWchannel,data));
            }
        }

        cout<<"\nCluster size "<< Hits.size() << endl;
        for(int c=0; c< Hits.size(); c++)
            cout << "Time difference : CH" << Hits[c].first << "  "<< eventTime-Hits[c].second << endl;
    } else {
        cout << "FIFO is not ready!\n";
    }
*/
    return true;
}
